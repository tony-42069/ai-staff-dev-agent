from typing import List, Dict, Any
from pydantic import BaseModel
import logging

class Capability(BaseModel):
    name: str
    description: str
    requirements: List[str]
    parameters: Dict[str, Any]

    def execute(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the capability.

        Args:
            task (Dict[str, Any]): The task parameters.

        Returns:
            Dict[str, Any]: The result of the capability execution with 'status' and optional 'message'.
        """
        try:
            raise NotImplementedError("Execute method must be implemented by subclass")
        except Exception as e:
            self.logger.error(f"Error executing capability '{self.name}': {e}")
            return {"status": "error", "message": str(e)}

class CapabilityManager:
    def __init__(self, config: Dict):
        self.config = config
        self.capabilities: Dict[str, Capability] = {}
        self.logger = logging.getLogger(__name__)
        self.initialize_capabilities()

    def initialize_capabilities(self):
        try:
            self.capabilities = {}
            for capability_config in self.config.get('capabilities', []):
                name = capability_config.get('name', 'unknown')
                try:
                    self.logger.info(f"Initializing capability: {name}")
                    capability = self.create_capability(capability_config)
                    self.capabilities[capability.name] = capability
                    self.logger.info(f"Capability '{name}' initialized successfully")
                except Exception as e:
                    self.logger.error(f"Error initializing capability '{name}': {e}")
            self.logger.info("All capabilities initialized")
        except Exception as e:
            self.logger.error(f"Capability initialization failed: {e}")
            raise

    def create_capability(self, config: Dict) -> Capability:
        """
        Create a capability instance from configuration.
        """
        try:
            implementation_name = config.get('implementation')
            if not implementation_name:
                raise ValueError("Implementation class not specified")
            
            # Assuming 'implementation' key in config points to a class
            implementation_class = config.pop('implementation')
            capability = implementation_class(**config)
            return capability
        except Exception as e:
            self.logger.error(f"Failed to create capability from config: {e}")
            raise

    def get_available_capabilities(self) -> List[str]:
        return list(self.capabilities.keys())

# Generic capability implementation template
class GenericCapability(Capability):
    def execute(self, task: Dict[str, Any]) -> Dict[str, Any]:
        try:
            self.logger.info(f"Executing capability '{self.name}' with task: {task}")
            
            # Extract parameters from the task
            param1 = task.get("param1")
            param2 = task.get("param2")
            
            # Add your capability execution logic here
            result = {"status": "success", "message": f"Capability '{self.name}' executed successfully."}
            return result
        except Exception as e:
            error_message = f"Error executing capability '{self.name}': {e}"
            self.logger.error(error_message)
            return {"status": "error", "message": error_message}

# Example configuration in YAML
capabilities_config = {
    'capabilities': [
        {
            'name': 'example_capability',
            'description': 'A generic example capability',
            'requirements': [],
            'parameters': {
                'param1': 'value1',
                'param2': 'value2'
            },
            'implementation': GenericCapability  # Reference to the generic implementation class
        }
        # Additional capabilities would follow the same structure
    ]
}
addAlignment
